// parametric surface equations for generating objects in run-time
// most surfaces are designed from aesthetic view


#ifndef __INC_GEOMETRY_H
#include "numerical/geometry.h"
#endif

// Parametric surface class
#include <functional>
#include <vector>
template<typename Fun>
class ParametricSurface {
public:
	double u0, u1, v0, v1;  // parameter intervals
	int uD, vD;  // recommended discretization splits
	const Fun P;  // equation, vec3 P(u,v)
	char name[32];  // optional
	bool isGaussianSurface;  // indicate whether divergence theorem can be applied
	ParametricSurface(Fun P,
		double u0 = NAN, double u1 = NAN, double v0 = NAN, double v1 = NAN, int uD = 0, int vD = 0,
		bool isGaussianSurface = false, const char* name = "")
		:u0(u0), u1(u1), v0(v0), v1(v1), uD(uD), vD(vD), P(P), isGaussianSurface(isGaussianSurface) {
		for (int i = 0; i < 32; i++) {
			if (!(this->name[i] = name[i])) break;
		}
	}
	static uint32_t hash(const char* s) {
		uint32_t h = 0;
		while (*s) h = 1664525u * h + 1013904223u * *(s++);
		return h;
	}

	// triangulation
	int param2points(std::vector<vec3> &p,
		vec3 translate = vec3(0.), double scale = 1.) const {
		p.reserve(p.size() + (uD + 1)*(vD + 1));
		double du = (u1 - u0) / uD, dv = (v1 - v0) / vD;
		for (int ui = 0; ui <= uD; ui++) {
			for (int vi = 0; vi <= vD; vi++) {
				double u = u0 + ui * du, v = v0 + vi * dv;
				p.push_back(scale * P(u, v) + translate);
			}
		}
		return (uD + 1)*(vD + 1);
	}
	// take a point list generated by `param2points` and generate triangles
	int points2trigs(const vec3* P, std::vector<triangle_3d> &T) const {
		T.reserve(T.size() + 2 * uD*vD);
		int NTrigs = 0;
		for (int ui = 0; ui < uD; ui++) {
			for (int vi = 0; vi < vD; vi++) {
				// normal direction: ∂p/∂u × ∂p/∂v
				vec3 p00 = P[ui*(vD + 1) + vi];
				vec3 p10 = P[ui*(vD + 1) + (vi + 1)];
				vec3 p01 = P[(ui + 1)*(vD + 1) + vi];
				vec3 p11 = P[(ui + 1)*(vD + 1) + (vi + 1)];
				if ((p01 - p10).sqr() < (p00 - p11).sqr()) {
					if (p10 != p00 && p10 != p01 && p00 != p01)
						T.push_back(triangle_3d(p10, p00, p01)), NTrigs++;
					if (p01 != p11 && p01 != p10 && p11 != p10)
						T.push_back(triangle_3d(p01, p11, p10)), NTrigs++;
				}
				else {
					if (p11 != p10 && p11 != p00 && p10 != p00)
						T.push_back(triangle_3d(p11, p10, p00)), NTrigs++;
					if (p00 != p01 && p00 != p11 && p01 != p11)
						T.push_back(triangle_3d(p00, p01, p11)), NTrigs++;
				}
			}
		}
		return NTrigs;
	}

	int param2trigs(std::vector<triangle_3d> &T,
		vec3 translate = vec3(0.), double scale = 1.) const {
		T.reserve(T.size() + 2 * uD*vD);
		std::vector<vec3> p;
		param2points(p, translate, scale);
		return points2trigs(&p[0], T);
	}
};
typedef ParametricSurface<vec3(*)(double, double)> ParametricSurfaceP;
typedef ParametricSurface<std::function<vec3(double, double)>> ParametricSurfaceL;




// surface templates

namespace ParametricSurfaceTemplates {

	vec3 Archimedean_snail(double u, double v,
		double vert, double offset, double layer_n) {

		/* 0 < u < 1, 0 < v < 2π
		   For a right-handed snail, all of the following are positive:
			- vert: height/sharpness, vertice=(0,0,vert)
			- offset: offset from z-axis, 1.0 for a "standard" snail
			- layer_n: number of layers of the snail
		*/

		return (1. - u)*vec3(
			(cos(v) + offset)*cossin(2.*PI*layer_n*u),
			sin(v)) + vec3(0, 0, vert*u);
	};

	vec3 Logarithmic_snail(double u, double v,
		double exp_k, double vert, double offset, double layer_n, bool right_handed) {

		/* u0 < u < u1, 0 < v < 2π
			- exp_k: r=exp(k/2π*θ), positive
			- vert: z_vertice = exp(exp_k)*vert
			- offset: offset from z-axis, 1.0 for a "standard" snail
			- layer_n: number of layers of the snail when -1<v<1
			- v0, v1: custom parameters, v0 can be -INFINITY
		*/

		return right_handed ?
			exp(exp_k*u) * vec3(
				sincos(PI*layer_n*u)*(offset + cos(v)),
				vert*(exp(exp_k - exp_k * u) - 2.) - sin(v)) :
			exp(exp_k*u) * vec3(
				cossin(PI*layer_n*u)*(offset + cos(v)),
				vert*(exp(exp_k - exp_k * u) - 2.) + sin(v));
	};


	template<typename vec> vec cubicBezierCurve(vec A, vec B, vec C, vec D, double t) {
		return (((-A + 3.*B - 3.*C + D)*t + (3.*A - 6.*B + 3.*C))*t + (3.*B - 3.*A))*t + A;
	}


	// swepts cv around cu, involves numerical differentiation
	vec3 Swept_Surface(std::function<vec3(double v, double u)> cv, std::function<vec3(double u)> cu, double u, double v, bool mainNormal) {
		const double eps = 1e-5;
		vec3 s0 = cu(u), sp = cu(u + eps), sm = cu(u - eps);
		vec3 dsdt = (sp - sm)*(.5 / eps);
		vec3 d2sdt2 = (sp + sm - 2.*s0) / (eps*eps);
		vec3 k = normalize(dsdt);
		vec3 i = mainNormal ? -d2sdt2 : cross(k, vec3(0, 0, 1)); i = normalize(i - dot(i, k)*k);
		vec3 j = cross(i, k);  // cross(k,i)??
		vec3 sv = cv(v, u);
		return s0 + i * sv.x + j * sv.y + k * sv.z;
	}
}



// preset parametric surfaces

const std::vector<ParametricSurfaceL> ParamSurfaces({

	/*[0]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 1.2, 1.0, 3.0);
	}, 0., 1., 0., 2.*PI, 120, 40, false, "land snail"),

	/*[1]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 2.2, 1.0, 4.5);
	}, 0., 1., 0., 2.*PI, 120, 40, false, "river snail"),

	/*[2]*/ ParametricSurfaceL([](double u, double v) {
			return ParametricSurfaceTemplates::Archimedean_snail(u, v, 1.1, 0.5, 2.0);
	}, 0., 1., 0., 2.*PI, 120, 40, false, "field snail"),

	/*[3]*/ ParametricSurfaceL([](double u, double v) {
			return ParametricSurfaceTemplates::Archimedean_snail(u, v, 1.8, 0.2, 2.4);
	}, 0., 1., 0., 2.*PI, 120, 40, false, "pond snail"),

	/*[4]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Archimedean_snail(u, v, 3.5, 0.2, 8.0);
		return vec3(0.75,0.75,1.4)*ParametricSurfaceTemplates::Archimedean_snail(u, v, 2.5, 0.6, 8.0);
	}, 0., 1., 0., 2.*PI, 120, 40, false, "cone snail"),

	/*[5]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.45, 1.7, 0.35, 2.1, true);
	}, -7., 1., 0., 2.*PI, 120, 40, false, "pot snail"),

	/*[6]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.65, 0.55, 0.86, 1.0, false);
	}, -6., 1., 0., 2.*PI, 160, 40, false, "moon snail"),

	/*[7]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.7, 0.0, 1.05, 1.0, false);
	}, -5., 1., 0., 2.*PI, 160, 40, false, "snail (in)"),

	/*[8]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 0.9, 0.0, 2.0, 1.0, false);
	}, -6., -1., 0., 2.*PI, 160, 40, false, "snail (out)"),

	/*[9]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Logarithmic_snail(u, v, 1.8, 1.2, 2.7, 1.0, false);
	}, -3., 1., 0., 2.*PI, 160, 40, false, "snail (outer)"),

	/*[10]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			cossin(3.*PI*u)*(2.0 + cos(v)) + 0.05*cossin(60.*PI*u),
			sin(v) + 0.05*sin(10.*v))*exp(u);
	}, -4., 1., 0., 2.*PI, 1000, 80, false, "textured snail 1"),

	/*[11]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			sincos(3.*PI*u)*(1. + cos(v)) + 0.1*cossin(-10.*v),
			4. - (u + 4.) - 0.9*sin(v))*exp(0.8*u);
	}, -4., 1., 0., 2.*PI, 800, 100, false, "textured snail 2"),

	/*[12]*/ ParametricSurfaceL([](double u, double v) {
		vec3 p = vec3(
			cossin(PI*3.*u)*(1. + cos(v)) + 0.1*cossin(40.*PI*u),
			(exp(1. - u) - 2.) + sin(v));
		p += 0.06*vec3(sin(10.*p.x)*sin(10.*p.y)*cos(10.*p.z));
		return p * exp(u);
	}, -3., 1., 0., 2.*PI, 1600, 100, false, "textured snail 3"),

	/*[13]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			sincos(3.*PI*u)*(0.9 + cos(v)) + 0.05*cossin(40.*PI*u)*cos(10.*v)*(1. + cos(v)),
			(exp(1.5 - 0.9*u) - 3.) - 1.1*sin(v))*exp(0.9*u);
	}, -4., 1., 0., 2.*PI, 800, 100, false, "textured snail 4"),

	/*[14]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(sincos(3.*PI*u)*(1. + cos(v)), -1.1*sin(v))
			*exp(0.8*u)*(.5*cos(20.*PI*u) + .9)*(.05*cos(10.*v) + 1.)
			+ vec3(0, 0, 5. - 4.*exp(u));
	}, -4., 1., 0., 2.*PI, 1000, 80, false, "textured snail #1"),

	/*[15]*/ ParametricSurfaceL([](double u, double v) {
		return vec3(
			(1 - .05*exp(sin(v)))*(cossin(3.*PI*u)*(2.0 + cos(v)) + 0.05*cossin(60.*PI*u)),
			-exp(1. - .5*u) + sin(v) + 0.1*sin(10.*v)*sin(20.*PI*u)*exp(u))*exp(u)
			+ vec3(0, 0, 4.);
	}, -4., 1., 0., 2.*PI, 1000, 100, false, "textured snail #2"),

	/*[16]*/ ParametricSurfaceL([](double u, double v) {
		return exp(u) * vec3(
			cossin(PI*3.*u)*(1. + cos(v)),
			(exp(1. - u) - 2.) + exp(u)*sin(v));
	}, -3., 1., 0., 2.*PI, 300, 60, false, "melon shell"),

	/*[17]*/ ParametricSurfaceL([](double u, double v) {
		vec3 p = exp(u) * vec3(
			cossin(PI*3.*u)*(1. + cos(v)),
			.55*(exp(1. - u) - 2.) + sin(v));
		return p + vec3(0, 0, 3. - exp(-.55*p.z));
	}, -3., 1., 0., 2.*PI, 300, 60, false, "bailer shell"),

	/*[18]*/ ParametricSurfaceL([](double u, double v) {
		vec2 cr(cos(v) + .2*sin(v)*sin(v), -1.3*sin(v) + cos(v)*cos(v));
		return exp(.4*u)*vec3((.5 + .8*cr.x + .3*cr.y)*sincos(PI*u),
			2.8*(exp(-.4*u) - 1.) + cr.y - .3*cr.x);
	}, -9., 1., 0., 2.*PI, 300, 60, false, "wonder shell"),

	/*[19]*/ ParametricSurfaceL([](double u, double v) {
		vec2 cr = vec2(0.510504, -1.134042)
			+ mat2(0.598892, 0.541083, -0.609437, -3.788403) * cossin(v)
			+ mat2(-0.120320, 0.732847, -0.350955, 0.994199) * cossin(2.*v)
			+ mat2(-0.078252, -0.453444, -0.022159, 0.324241) * cossin(3.*v);
		cr.y = 5.*tanh(.2*cr.y);  // too sharp
		cr.y = .2*log(exp(5.*cr.y) + exp(5.*-3.6));  // clamp at y=-3.6 like that of natural snail
		return exp(.3*u)*vec3(cr.x*sincos(PI*u),
			3.*(exp(-.3*u) - 1.) + cr.y);
	}, -9., 1., 0., 2.*PI, 300, 60, false, "pear shell"),

	/*[20]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 1.0;
		return vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
	}, 0, 2.*PI, 0., 2.*PI, 80, 40, true, "torus"),

	/*[21]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 0.7 + 0.4*cos(u);
		vec2 uv = vec2(cos(v) - 0.2*cos(2.*v), sin(v) + 0.2*sin(2.*v));
		return vec3(cossin(u)*(R + r * uv.x), r*uv.y);
	}, 0, 2.*PI, 0., 2.*PI, 100, 60, true, "uneven torus"),

	/*[22]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 1.0 + 0.8*sin(5.*u)*sin(v);
		return vec3(cossin(u)*(R + r * cos(v)), sin(v));
	}, 0, 2.*PI, 0., 2.*PI, 120, 60, true, "deformed torus 1"),

	/*[23]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 0.8*exp(sin(5.*u)) - 0.2;
		return vec3(cossin(u)*(R + r * cos(v)), .5*r*sin(v));
	}, 0, 2.*PI, 0., 2.*PI, 200, 60, true, "deformed torus 2"),

	/*[24]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 0.8 - .1*pow(.5 - .5*min(sin(12.*u), sin(10.*v)), 10.);
		return vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
	}, 0, 2.*PI, 0., 2.*PI, 360, 180, true, "textured torus (tire)"),

	/*[25]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 0.8 + .1*pow(abs(min(sin(10.*v), sin(10.*u))), 10.);
		return vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
	}, 0., 2.*PI, 0, 2.*PI, 480, 300, true, "textured torus (cells)"),

	/*[26]*/ ParametricSurfaceL([](double u, double v) {
		double texture = 0.1*pow(1.0 - pow((sin(5.*v) - .5*sin(16.*u)) / 1.5, 2.), 20.);
		double R = 2.0, r = 0.8 + texture;
		return vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
	}, 0, 2.*PI, 0., 2.*PI, 360, 180, true, "textured torus (wavy)"),

	/*[27]*/ ParametricSurfaceL([](double u, double v) {
		vec2 p = vec2(20.*v, 66.*u / sqrt(3.)) / (2.*PI);
		p = vec2(fmod(p.x, 3.), fmod(.5*p.x + sqrt(3)*.5*p.y, 3.));
		if (p.y > p.x) p = p.yx();
		if (p.x + p.y > 3.) p = vec2(3.) - p.yx();
		double texture = p.y > 1. ? p.x - p.y : p.x > 2. ? abs(p.x - p.y - 2.) : p.y > p.x - 1. ? abs(p.x - 1.) : p.y;
		double R = 2.0, r = 0.8 + 0.1*pow(1.0 - texture * texture, 20.);
		return vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
	}, 0., 2.*PI, 0, 2.*PI, 360, 180, true, "textured torus (hexa)"),

	/*[28]*/ ParametricSurfaceL([](double u, double v) {
		double R = hypot(2.5*cos(u) - 0.1*cos(3.*u), 2.5*sin(u) + 0.1*sin(3.*u));
		double r = hypot(0.8*cos(v) - 0.05*cos(3.*v), 0.8*sin(v) + 0.05*sin(3.*v));
		vec3 p = vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
		return p + vec3(0, 0, 0.1*p.x*p.y + 0.1*p.y*p.y);
	}, 0., 2.*PI, 0, 2.*PI, 100, 60, true, "bended torus"),

	/*[29]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 0.8;
		vec3 p = vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
		return (rotationMatrix_y(1.5*p.y)*p).rx90();
	}, 0., 2.*PI, 0, 2.*PI, 200, 60, true, "twisted torus"),

	/*[30]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0;
		double r = hypot(0.3*cos(v) - 0.02*cos(3.*v), 0.3*sin(v) + 0.02*sin(3.*v));
		vec3 p = vec3(cossin(u)*(R + r * cos(v)), 0.4*r*sin(v));
		return p * vec3(1, 0.8, 1) + vec3(0, 1.1*(pow(p.x*p.x + 1e-4, .25) - 1.), 0);
	}, 0., 2.*PI, 0, 2.*PI, 400, 40, true, "toric heart"),

	/*[31]*/ ParametricSurfaceL([](double u, double v) {
		double R = 2.0, r = 0.3;
		vec3 p = vec3(cossin(u)*(R + r * cos(v)), r*sin(v));
		p += asin(sin(5.*atan2(p.y, p.x))) * vec3(normalize(p.xy()));
		return p * vec3(1, 1, 0.04*(p.x*p.x + p.y*p.y) + 0.8);
	}, 0., 2.*PI, 0, 2.*PI, 400, 40, true, "toric cercis"),

	/*[32]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = ParametricSurfaceTemplates::cubicBezierCurve(vec2(0, -1), vec2(1.2, -1), vec2(0.6, 1), vec2(0, 1), v);
		return vec3(cossin(u)*c.x, c.y);
	}, 0, 2.*PI, 0., 1., 80, 40, true, "egg"),

	/*[33]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = ParametricSurfaceTemplates::cubicBezierCurve(vec2(0, -1), vec2(1, -1), vec2(0.6, 0.3), vec2(0, 1), v);
		vec3 p = vec3(cossin(u)*c.x, c.y);
		return p - vec3(0, 0.1*p.z*p.z, 0);
	}, 0, 2.*PI, 0., 1., 80, 40, true, "droplet"),

	/*[34]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = vec2(0.7*sin(v) + 0.25*sin(2.*v) + 0.3*sin(3.*v), -2.*cos(v) - 0.3*cos(2.*v) - 0.3*cos(3.*v));
		return vec3(cossin(u)*c.x, c.y);
	}, 0, 2.*PI, 0., PI, 60, 60, true, "bowling"),

	/*[35]*/ ParametricSurfaceL([](double u, double v) {
		v *= 1.45; vec3 s1 = vec3(cossin(u)*(0.7*sin(v) + 0.25*sin(2.*v) + 0.3*sin(3.*v)), (-1.*cos(v) - 0.2*cos(2.*v) - 0.2*cos(3.*v)));
		v /= 1.45; vec3 s2 = vec3(cossin(u)*(0.075*sin(v) + 0.015*sin(3.*v)), (-1.6*cos(v) + 0.2*cos(3.*v))) + vec3(0, .04*cos(2.*v), 0);
		return s1 + (s2 - s1)*(.5 - .5*tanh(40.*(.5 + cos(v))));
	}, 0, 2.*PI, 0., PI, 60, 200, true, "gourd"),

	/*[36]*/ ParametricSurfaceL([](double u, double v) {
		v *= 1.34; vec2 c = vec2(sin(v) + 0.1*pow(sin(v), 5), -cos(v) + 0.3*pow(cos(v), 5));
		c *= vec2(1.0) + vec2(0.08, 0.08*c.x*c.x)*sin(cos(8.*u));
		vec3 s1 = vec3(cossin(u)*c.x, c.y);
		v /= 1.34; vec3 s2 = vec3(cossin(u)*(0.2*sin(v) + 0.04*sin(3.*v)), (-1.25*cos(v) + 0.16*cos(3.*v))) + vec3(0, .06*cos(2.3*v), 0);
		return s1 + (s2 - s1)*(.5 - .5*tanh(40.*(.6 + cos(v))));
	}, 0., 2.*PI, 0, PI, 120, 200, true, "pumpkin"),

	/*[37]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = vec2(sin(v) - 0.04*sin(2.*v), -cos(v) - exp(1.3*cos(v)) + 0.6*sin(v)*sin(v) + 1.3);
		vec3 s = vec3(cossin(u)*c.x, c.y);
		s.x -= 0.08*s.z*s.z; return s;
	}, 0., 2.*PI, 0, PI, 60, 60, true, "pepper (without stem)"),

	/*[38]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = vec2(sin(v), -1.2*cos(v) - 0.2*cos(2.*v));
		c *= vec2(1.0) + vec2(0.05, 0.05*c.x*c.x)*asin(0.95*cos(12.*u)) + vec2(0.02, 0.)*cos(12.*(u + v));
		return vec3(cossin(u)*c.x, c.y);
	}, 2.*PI, 0., PI, 0, 200, 90, true, "ball cactus"),

	/*[39]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = ParametricSurfaceTemplates::cubicBezierCurve(vec2(0, -1), vec2(2.2, -1), vec2(0.3, 1), vec2(0, 2), v);
		c *= vec2(1.0) + vec2(0.1, 0.1*c.x*c.x)*asin(0.98*cos(5.*u));
		return rotationMatrix_z(c.y)*(vec3(cossin(u)*c.x, c.y) + vec3(0.1*sin(c.y), 0, 0));
	}, 0, 2.*PI, 0., 1., 120, 60, true, "ice cream"),

	/*[40]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = pow(u, 1.5) * (1. + 0.01*sin(60.*v)) * vec2(sin(v), (1. - .2*exp(-10 * sin(v)))*pow(u, 1.5)*(-cos(v) + 0.2*cos(3.*v) - 0.1*sin(2.*v) + 0.2*sin(v)));
		return vec3(pow(1. + 0.05*u*u - exp(-5.*u), 2.), 1, 2.*u - 1.4*u*u)*vec3(cossin(2.*PI*u)*c.x, c.y).rx270();
	}, 0, 1., 0., PI, 80, 240, false, "ark clam"),

	/*[41]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = u * (1. + .01*sin(80.*PI*u)) * vec2(sin(v), sqrt(u) * (-cos(v) - 0.1*sin(2.*v)))*(0.2 + 0.8*sin(v));
		return vec3(1., 1., .6)*vec3(cossin(PI*(.1 + .9*u))*c.x, c.y).rx270().ry180();
	}, 0, 1., 0., PI, 240, 80, false, "Asian clam"),

	/*[42]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = u * (1. + .002*sin(50.*PI*u) + .001*sin(60.*PI*u)) * vec2(sin(v), 2.*pow(sin(v), 0.2)*tanh(1.5*(-cos(v) - 0.2*sin(3.*v))));
		vec3 p = vec3(cossin(PI*(.5 + .5*u))*c.x, c.y).rx270().ry180();
		p.z = 0.4*p.z + 0.1*sin(PI*p.x); return p.rz90();
	}, 0, 1., 0., PI, 120, 120, false, "razor clam"),

	/*[43]*/ ParametricSurfaceL([](double u, double v) {
		vec2 c = u * u * (1. + .003*sin(70.*PI*u) + .002*sin(80.*PI*u)) * vec2(2.*sin(v)*sin(v) + 0.3*sin(3.*v), -0.85*sin(v)*cos(v) + 0.1*sin(3.*v));
		return vec3(cossin(PI*(.4 + .6*u))*vec2(1., 0.5)*c.x, c.y).rx270().ry180();
	}, 0, 1., 0., PI, 240, 80, false, "mussel clam"),

	/*[44]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Swept_Surface(
			[](double v, double u) { return 0.2*rotationMatrix_z(3.*u)*vec3(cos(v) - 0.1*cos(3.*v), sin(v) + 0.1*sin(3.*v), 0.); },
			[](double t) { return vec3(cos(t), 1.618*sin(t), 0.25*sin(2.*t)); },
			u, v, true);
	}, 0., 2.*PI, 0, 2.*PI, 160, 80, true, "elliptic twist"),

	/*[45]*/ ParametricSurfaceL([](double u, double v) {
		return  ParametricSurfaceTemplates::Swept_Surface(
			[](double v, double u) { return 0.3*rotationMatrix_z(3.*u)*vec3(cos(v), 0.5*sin(v), 0.); },
			[](double t) {
				vec3 p = vec3(2.*cos(t) - 0.1*sin(3.*t), sin(t) + 0.15*sin(3.*t), 0.);
				return rotationMatrix_x(-3.*p.x)*p*vec3(-1, 1, -0.6);
			},
			u, v, false);
	}, 0., 2.*PI, 0, 2.*PI, 400, 40, true, "dough twist"),

	/*[46]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Swept_Surface(
			[](double v, double u) { return 0.5*rotationMatrix_z(5.*u)*vec3(cos(v) + 0.15*cos(6.*v), sin(v) + 0.15*sin(6.*v), 0.); },
			[](double t) { return vec3(cossin(2.*t)*(3. + sin(5.*t)), cos(5.*t)); },
			u, v, true);
	}, 0., 2.*PI, 0, 2.*PI, 240, 80, true, "cinquefoil bundle"),

	/*[47]*/ ParametricSurfaceL([](double u, double v) {
		return ParametricSurfaceTemplates::Swept_Surface(
			[](double v, double u) { return vec3(0.15*cossin(v), 0); },
			[](double t) { return vec3(3.*cossin(t) + cos(36.*t)*cossin(t), sin(36.*t)); },
			u, v, true);
	}, 0., 2.*PI, 0, 2.*PI, 1800, 20, true, "circular solenoid"),

});



// provide information about preset surfaces when triangulated by default
// ParamSurfaceInfo::info[].
// @name: name of the surface, same as ParamSurfaces[].name
// @Trig_N: number of triangles
// @isSolid: solid or surface, closed or not
// @AABB_min, @AABB_max: axis-aligned bounding box
// @SA_or_V: the surface area (surface) or volume (solid) of the shape
// @CoM: center of mass of the object, assuming uniform density
// @InertiaTensor_u: multiply this by the mass of the object to get the inertia tensor calculated at center of mass
// @minGravPotential_vec: a local minimum of function E(n)=max([dot(n,p-CoM) for p in shape]) subject to |n|==1,
//                        the shape will be physically balanced when placed on a horizontal plane with this direction facing down
// @minGravPotential_u: height of center of mass above the plane when placed with @minGravPotential_vec facing down

namespace ParamSurfaceInfo {
#include "surfaces_info.h"
}




// functions that may be useful for normalizing test shapes

// calculate the center of mass of an object
// assume the object is a surface with uniform surface density
vec3 calcCOM_shell(const triangle_3d* T, int N) {
	double A = 0; vec3 C(0.);
	for (int i = 0; i < N; i++) {
		double dA = T[i].area();
		vec3 dC = T[i].center();
		A += dA, C += dA * dC;
	}
	return C * (1. / A);
}
// calculate the axis-aligned bounding box, return the center
vec3 calcAABB(const triangle_3d* T, int N, vec3* rad = 0) {
	const vec3* P = (vec3*)T; N *= 3;
	vec3 Min(INFINITY), Max(-INFINITY);
	for (int i = 0; i < N; i++) {
		Max = pMax(Max, P[i]);
		Min = pMin(Min, P[i]);
	}
	if (rad) *rad = .5*(Max - Min);
	return .5*(Max + Min);
}

// translate the object so its center is the origin
void translateShape(triangle_3d* T, int N, vec3 d) {
	vec3* P = (vec3*)T; N *= 3;
	for (int i = 0; i < N; i++) P[i] += d;
}
void translateToCOM_shell(triangle_3d* T, int N) {
	translateShape(T, N, -calcCOM_shell(T, N));
}
void translateToAABBCenter(triangle_3d* T, int N) {
	translateShape(T, N, -calcAABB(T, N));
}

// place the object on the xOy plane
void translateShape_onPlane(triangle_3d* T, int N) {
	vec3 *P = (vec3*)T; N *= 3;
	double min_z = INFINITY;
	for (int i = 0; i < N; i++) min_z = min(min_z, P[i].z);
	translateShape(T, N / 3, vec3(0, 0, -min_z));
}


// calculate the maximum "radius" of the object from the origin
double calcMaxRadius(const triangle_3d* T, int N) {
	const vec3* P = (vec3*)T; N *= 3;
	double maxR = 0.;
	for (int i = 0; i < N; i++) {
		double r = P[i].sqr();
		if (r > maxR) maxR = r;
	}
	return sqrt(maxR);
}
// calculate the radius of gyration of an object, assuming uniform surface density
double calcGyrationRadius_shell(const triangle_3d* T, int N) {
	// not sure if I calculated this correctly
	double A = 0.; mat3 I(0.);
	for (int i = 0; i < N; i++) {
		vec3 a = T[i][0], b = T[i][1], c = T[i][2];
		double dA = 0.5*length(cross(b - a, c - a));
		A += dA;
		I += dA / 6. *(mat3(dot(a, a) + dot(b, b) + dot(c, c) + dot(a, b) + dot(a, c) + dot(b, c)) -
			(tensor(a, a) + tensor(b, b) + tensor(c, c) + 0.5*(tensor(a, b) + tensor(a, c) + tensor(b, a) + tensor(b, c) + tensor(c, a) + tensor(c, b))));
	}
	return sqrt(cbrt(determinant(I)) / A);
}
// calculate sqrt[∫(r²dS)/∫(dS)], assume the object is a surface
double calcRotationRadius_shell(const triangle_3d* T, int N) {
	double I = 0., S = 0.;
	for (int i = 0; i < N; i++) {
		vec3 a = T[i][0], b = T[i][1], c = T[i][2];
		double dS = 0.5*length(cross(b - a, c - a));
		double dI = (1. / 12.)*(a.sqr() + b.sqr() + c.sqr() + dot(a, b) + dot(a, c) + dot(b, c));
		S += dS, I += dI * dS;
	}
	return sqrt(I / S);
}


// scale the object to a fixed size
// visually, scaleGyrationRadiusTo works best but it is the slowest
void scaleMaxRadiusTo(triangle_3d* T, int N, double r) {
	double s = r / calcMaxRadius(T, N);
	for (int i = 0; i < N; i++) T[i].scale(s);
}
void scaleGyrationRadiusTo_shell(triangle_3d* T, int N, double r) {
	double s = r / calcGyrationRadius_shell(T, N);
	for (int i = 0; i < N; i++) T[i].scale(s);
}
void scaleRotationRadiusTo_shell(triangle_3d* T, int N, double r) {
	double s = r / calcRotationRadius_shell(T, N);
	for (int i = 0; i < N; i++) T[i].scale(s);
}

