#define r(x,y,z) length(p-vec3(x,y,z))
float sdf(in vec3 p) {
    //if (dot(p, p) > 1.1)  return length(p) - 1.0;
//return -.272+.065*r(.101,.553,.331)-.272*r(-.347,-.086,.29)-.374*r(.048,-.416,.754)+.283*r(-.23,-.469,-.195)+.125*r(.308,.196,.224)-.325*r(-.826,-.504,-.243)-.196*r(1.064,1.189,.744)+.086*r(.087,-.264,-.124)-.31*r(-.822,.215,.263)+.317*r(.115,-.405,.259)-.337*r(.471,.21,.637)+.098*r(-.319,.775,.191)+.707*r(-.35,.229,.62)+.121*r(.538,.568,.487)-.344*r(-.603,-.227,.01)-.492*r(.041,.486,.572)+.101*r(.087,-.264,-.124)+.245*r(.086,.207,-.318)+.122*r(.091,.746,-.611)+.677*r(-.341,-.417,.44)-.29*r(.351,-.268,-.008)+.251*r(.087,-.267,-.125)-.653*r(-.304,-.205,.76)+.49*r(.248,-.418,.302)+.14*r(.087,-.265,-.124)-.559*r(.448,-.183,-.423)+.311*r(.478,.026,-.703)-.412*r(.418,-.139,.131)+.908*r(-.093,-.021,.526)+.34*r(.826,-.558,.452)+.491*r(-.571,.038,-.142)+.715*r(-.52,-.429,.666)-.457*r(-.396,-.125,.589)+.256*r(.087,-.267,-.125)+.264*r(.091,.747,-.611)+.309*r(.055,.31,.127)+.291*r(.106,.166,.012)-.723*r(-.197,-.257,-.455)-.754*r(.101,.043,-.877)+.041*r(.086,-.258,-.122)-.296*r(-.312,-.814,.2)-.426*r(-.244,-.489,.098)-.258*r(-.387,.598,.392)-.152*r(-.961,.951,-.483)-.355*r(.194,-.063,.26)+.627*r(-.146,.106,.808)-.299*r(-.134,.193,.26)+.263*r(.086,.207,-.318)-.452*r(.836,-.721,-.549)-.295*r(.797,-.052,.32)+.296*r(-.323,-.043,-.742)+.739*r(-.676,-.306,.414)+.138*r(.268,.613,.424)+.078*r(.086,.205,-.314)-.541*r(-.533,.025,.245)+.188*r(.544,.341,.403)-.465*r(-.242,-.152,.251)-.397*r(.179,.155,.443)+.645*r(.443,-.331,-.729)-.336*r(.042,-.057,.214)+.421*r(.495,-.475,.149)+.073*r(.295,.243,.26)-.176*r(-.179,-1.1,.891)+.573*r(-.15,-.279,-.735);
return -.161-.507*r(-.302,-.419,-.529)-.332*r(-.186,-.418,.122)-.061*r(.825,1.099,-.185)+.332*r(.049,-.171,-.087)+.191*r(.044,.445,-.067)-.505*r(.061,-.419,.723)-.08*r(.658,.155,.643)+.152*r(.076,-.249,-.174)-.363*r(-.87,.201,.222)+.213*r(.081,-.298,-.185)-.354*r(.503,.188,.628)+.227*r(.284,.186,.255)-.281*r(-.135,-.084,-.275)-.187*r(-.138,.198,-.12)-.403*r(-.649,-.186,.05)-.337*r(.445,.575,-.462)+.158*r(.032,.178,.017)+.312*r(.097,.285,-.301)-.338*r(.123,.711,-.224)+.273*r(.522,-.209,.539)-.407*r(-.194,-.213,.249)+.29*r(-.014,.181,-.305)-.774*r(.186,-.435,-.501)+.357*r(.212,-.466,-.251)+.442*r(-.225,-.106,-.65)-.459*r(.275,-.54,-.055)+.427*r(.656,.051,-.187)-.469*r(.548,-.114,.068)+.519*r(.413,-.507,.125)+.262*r(.154,-.345,-.199)+.77*r(.393,-.352,-.679)+1.217*r(-.082,-.048,.579)-.566*r(-.462,-.079,.671)+.312*r(.525,.284,.426)+.198*r(.398,.359,-.636)+.518*r(-.622,.063,-.118)+.294*r(-.228,.608,.155)-.898*r(.077,.067,-.875)-.362*r(-.582,.023,.216)+.129*r(.045,.028,-.129)-.298*r(.46,-1.088,-.904)-.376*r(-.371,-.61,.021)-.283*r(-.544,.192,-.605)-.197*r(-.575,.691,.332)-.46*r(.142,-.1,.221)+.458*r(.109,-.396,.186)-.382*r(-.222,.501,.382)+.454*r(-.328,.037,-.286)-.734*r(.447,-.104,-.431)-.314*r(.813,-.01,.326)+.665*r(-.023,-.435,-.706)+.337*r(.696,-.442,.193)-.195*r(-.138,.25,-.121)+.464*r(-.37,-.177,-.729)-.775*r(-.289,-.234,.698)+.304*r(.229,.569,.363)-.754*r(-.229,-.158,-.453)-.41*r(.085,.285,.46)+.211*r(.096,.284,-.3)-.423*r(-.3,-.177,.525)+.502*r(.195,-.429,.316)+.268*r(-.265,.282,-.716)-.345*r(-.245,-.777,.325)+.182*r(.081,-.289,-.183)-.303*r(-.172,.64,-.421)+.505*r(-.289,-.53,-.239)+.962*r(-.524,-.372,.649)-.333*r(.086,.615,.616)-.334*r(-.844,-.486,-.208)+.783*r(.118,.752,-.483)-.293*r(-.04,.07,.23)-.41*r(.309,-.231,.027)-.584*r(-.398,-.065,.27)-.406*r(.814,-.278,-.355)+1.217*r(-.311,.188,.674)+.804*r(-.679,-.269,.349)+.976*r(-.305,-.407,.438)-.474*r(.286,.015,.405)+.326*r(.058,.275,.09)+.48*r(.468,-.018,-.658);
}

vec3 sdfGrad(vec3 p) {
    mat3 k = mat3(p,p,p) - mat3(0.001);
    return normalize(sdf(p) - vec3(sdf(k[0]),sdf(k[1]),sdf(k[2])));
}


#define PI 3.1415926

// raymarching parameters
const vec3 BoxRadius = vec3(1.0);
#define STEP 0.03
#define MAX_STEP 80.


// rendering parameters
#define FIELD_EMISSION 0.3
#define DISCONTINUITY_OPACITY 0.1
#define SURFACE_GRADIENT 10.0

// light direction as global variable
vec3 light = normalize(vec3(0.5,0.5,1.0));

// colormaps - https://www.shadertoy.com/view/NsSSRK
vec3 colorSdf(float t) {
  float r = .385+.619*t+.238*cos(4.903*t-2.61);
  float g = -5.491+.959*t+6.089*cos(.968*t-.329);
  float b = 1.107-.734*t+.172*cos(6.07*t-2.741);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}
vec3 colorNormal(float t) {
  float r = .529-.054*t+.55*cos(5.498*t+2.779);
  float g = .21+.512*t+.622*cos(4.817*t-1.552);
  float b = .602-.212*t+.569*cos(5.266*t+2.861);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}


vec3 render(in vec3 ro, in vec3 rd, float t0, float t1) {
    float step_count = min(ceil((t1-t0)/STEP), MAX_STEP);
    float t = t0, dt = (t1-t0) / step_count;
    vec3 totcol = vec3(0.0);
    float totabs = 1.0;
    float v_old, v;
    for (t = t0; t < t1; t += dt) {
        v = sdf(ro+rd*t);
        vec3 col = colorSdf(0.5+0.5*sin(16.0*PI*v));
        float grad = t==t0 ? 0.0 : abs(v-v_old)/dt;
        float grad_abs = (1.0-grad)/dt;
        col = mix(vec3(1,0,0), col, clamp(exp(grad_abs),0.0,1.0));
        float absorb = FIELD_EMISSION+DISCONTINUITY_OPACITY*max(-grad_abs,0.0);
        totabs *= exp(-absorb*dt);
        totcol += col*absorb*totabs*dt;
        if (v < 0.0) break;
        v_old = v;
    }
    if (v > 0.0) return totcol;
    for (int s = 0; s < 4; s += 1) {
        v_old = v;
        dt *= -0.5;
        for (int i = 0; i < 2; i++) {
            t += dt;
            v = sdf(ro+rd*t);
            if (v*v_old<0.0) break;
        }
    }
    vec3 grad = sdfGrad(ro+rd*t);
    vec3 col = colorNormal(0.5+0.5*tanh(SURFACE_GRADIENT*(0.5*length(grad)-0.5)));
    col = 0.2+0.05*grad.y+col*max(dot(normalize(grad), light),0.0);
    return totcol + col * totabs;
}


// ray intersection with a box
bool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {
    vec3 inv_rd = 1.0 / rd;
    vec3 n = inv_rd*(ro);
    vec3 k = abs(inv_rd)*BoxRadius;
    vec3 t1 = -n - k, t2 = -n + k;
    tn = max(max(t1.x, t1.y), t1.z);
    tf = min(min(t2.x, t2.y), t2.z);
    if (tn > tf) return false;
    return true;
}

// main
void mainImage(out vec4 fragColor, in vec2 fragCoord) {

    // set camera
    float rx = iMouse.z!=0. ? 3.14*(iMouse.y/iResolution.y)-1.57 : 0.3;
    float rz = iMouse.z!=0. ? -iMouse.x/iResolution.x*4.0*3.14 : -0.6;

    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));
    vec3 u = vec3(-sin(rz),cos(rz),0);
    vec3 v = cross(w,u);

    vec3 ro = 8.0*w;
    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);
    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));
    rd = normalize(rd);

    // calculate pixel color
    light = normalize(w+0.5*u+0.1*v);

    float t0, t1;
    if (!boxIntersection(ro, rd, t0, t1)) {
        fragColor = vec4(vec3(0.0), 1.0);
        return;
    }
    vec3 col = render(ro, rd, t0, t1);;
    fragColor = vec4(col, 1.0);
}
