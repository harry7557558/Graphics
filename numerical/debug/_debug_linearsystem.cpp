// linear system solver test

#include <stdio.h>
int maxIter = 0;

#include "linearsystem.h"
#include "eigensystem.h"
#include "random.h"


const double rand_std = 10.0;  // standard derivation
void randomSymmetricMatrix(int N, double *M) {
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			M[i*N + j] = randf_n(rand_std);
		}
	}
	for (int i = 0; i < N; i++) {
		for (int j = 0; j <= i; j++) {
			M[i*N + j] = (M[j*N + i] += M[i*N + j]);
		}
	}
}
void randomVector(int N, double *A) {
	for (int i = 0; i < N; i++) {
		A[i] = 2.0*randf_n(rand_std);
	}
}



// large arrays as global variables
#define N 250
double A[N][N], B[N], X[N], AX[N];


// conjugate gradient should converge in no more than N iterations
// but that number seems to be larger for large matrices due to floating-point truncation...
void testConjugateGradientIteration() {

	for (int D = 2; D <= N; D++) {
		const int TN = 50;
		double rmse = 0.0;
		maxIter = 0;
		for (int T = 0; T < TN; T++) {
			_SRAND(T);
			randomSymmetricMatrix(D, &A[0][0]);
			randomVector(D, &B[0]);
			for (int i = 0; i < D; i++) X[i] = 0;
			solveLinear_ConjugateGradient(D, &A[0][0], B, X);
			matvecmul(D, &A[0][0], X, AX);
			for (int i = 0; i < D; i++) AX[i] -= B[i];
			double err = vecdot(D, AX, AX);
			rmse += err;
			//printf("%.12lf\n", sqrt(err));
		}
		printf("%d %d \t%lg\n", D, maxIter, sqrt(rmse / TN));
	}

	// [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,10),(10,9),(11,10),(12,11),(13,13),(14,14),(15,18),(16,17),(17,19),(18,21),(19,22),(20,31),(21,25),(22,30),(23,26),(24,31),(25,31),(26,32),(27,33),(28,39),(29,40),(30,50),(31,39),(32,43),(33,45),(34,44),(35,49),(36,49),(37,56),(38,62),(39,62),(40,59),(41,59),(42,59),(43,62),(44,73),(45,92),(46,79),(47,69),(48,74),(49,77),(50,82),(51,79),(52,88),(53,87),(54,83),(55,86),(56,80),(57,90),(58,81),(59,92),(60,91),(61,90),(62,114),(63,110),(64,192),(65,108),(66,100),(67,142),(68,188),(69,112),(70,224),(71,126),(72,157),(73,120),(74,119),(75,165),(76,165),(77,202),(78,118),(79,186),(80,122),(81,123),(82,127),(83,132),(84,134),(85,133),(86,163),(87,141),(88,185),(89,207),(90,199),(91,231),(92,257),(93,202),(94,249),(95,207),(96,196),(97,197),(98,267),(99,167),(100,198),(101,221),(102,249),(103,180),(104,200),(105,279),(106,219),(107,277),(108,210),(109,213),(110,202),(111,238),(112,229),(113,235),(114,227),(115,293),(116,432),(117,216),(118,204),(119,339),(120,220),(121,322),(122,287),(123,258),(124,220),(125,247),(126,323),(127,224),(128,262),(129,348),(130,313),(131,347),(132,313),(133,284),(134,549),(135,382),(136,296),(137,432),(138,388),(139,279),(140,298),(141,335),(142,362),(143,289),(144,416),(145,308),(146,462),(147,386),(148,315),(149,474),(150,436),(151,470),(152,381),(153,395),(154,462),(155,471),(156,448),(157,376),(158,407),(159,441),(160,717),(161,348),(162,401),(163,337),(164,459),(165,525),(166,388),(167,315),(168,454),(169,548),(170,494),(171,384),(172,541),(173,545),(174,395),(175,435),(176,538),(177,509),(178,535),(179,418),(180,506),(181,541),(182,490),(183,892),(184,582),(185,395),(186,600),(187,438),(188,410),(189,575),(190,586),(191,572),(192,600),(193,573),(194,483),(195,408),(196,706),(197,607),(198,723),(199,647),(200,602),(201,611),(202,576),(203,629),(204,592),(205,634),(206,634),(207,638),(208,634),(209,648),(210,564),(211,679),(212,510),(213,658),(214,577),(215,670),(216,689),(217,644),(218,704),(219,817),(220,668),(221,638),(222,431),(223,679),(224,677),(225,744),(226,800),(227,647),(228,750),(229,782),(230,486),(231,598),(232,750),(233,640),(234,732),(235,756),(236,680),(237,945),(238,821),(239,763),(240,907),(241,732),(242,838),(243,910),(244,791),(245,727),(246,801),(247,785),(248,814),(249,805),(250,791)]

}

#include <chrono>
int main() {
	auto t0 = std::chrono::high_resolution_clock::now();

	const int TN = 100;
	double rmse = 0.0;
	for (int T = 0; T < TN; T++) {
		_SRAND(T);
		randomSymmetricMatrix(N, &A[0][0]);
		randomVector(N, &B[0]);
#if 0
		veccpy(N, B, X);
		solveLinear(N, &A[0][0], X);
#else
		for (int i = 0; i < N; i++) X[i] = 0;
		solveLinear_ConjugateGradient(N, &A[0][0], B, X);
#endif
		matvecmul(N, &A[0][0], X, AX);
		for (int i = 0; i < N; i++) AX[i] -= B[i];
		double err = vecdot(N, AX, AX);
		rmse += err;
		printf("%.12lf\n", sqrt(err));
	}
	printf("RMSE: %lg\n", sqrt(rmse / TN));

	double time_elapsed = std::chrono::duration<double>(std::chrono::high_resolution_clock::now() - t0).count();
	printf("%lf secs\n", time_elapsed);
	return 0;
}
